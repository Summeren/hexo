{"meta":{"title":"Apple","subtitle":null,"description":null,"author":"Apple","url":"http://blog.xueni.ren"},"pages":[{"title":"about","date":"2016-05-31T04:34:20.000Z","updated":"2016-11-04T09:08:15.341Z","comments":true,"path":"about/index.html","permalink":"http://blog.xueni.ren/about/index.html","excerpt":"","text":"Apple 是一只程序喵。"},{"title":"tags","date":"2016-05-31T04:35:48.000Z","updated":"2016-11-04T09:08:15.341Z","comments":true,"path":"tags/index.html","permalink":"http://blog.xueni.ren/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"TRUNCATE 和 DELETE 的区别","slug":"MySQL-truncate-delete","date":"2016-11-14T14:15:00.000Z","updated":"2016-11-04T09:08:15.337Z","comments":true,"path":"2016/11/14/MySQL-truncate-delete/","link":"","permalink":"http://blog.xueni.ren/2016/11/14/MySQL-truncate-delete/","excerpt":"前言 工作中有这么一个业务场景，数据库里的数据需要定时全量删除。全量删除数据有两个选择，1：DELETE FROM table_name 2:TRUNCATE TABLE table_name。由于 TRUNCATE TABLE 相当于不带 WHERE 条件的 DELETE 语句，那么不论是选择 DELETE 还是选择 TRUNCATE TABLE 好像都能达到我删除全量数据的目的。","text":"前言 工作中有这么一个业务场景，数据库里的数据需要定时全量删除。全量删除数据有两个选择，1：DELETE FROM table_name 2:TRUNCATE TABLE table_name。由于 TRUNCATE TABLE 相当于不带 WHERE 条件的 DELETE 语句，那么不论是选择 DELETE 还是选择 TRUNCATE TABLE 好像都能达到我删除全量数据的目的。 DELETE 语法DELETE 语句大家都熟悉，语法如下： 123456789101112131415161718&lt;!-- 单表操作 --&gt;DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name [PARTITION (partition_name,...)] [WHERE where_condition] [ORDER BY ...] [LIMIT row_count] &lt;!-- 多表操作1 --&gt;DELETE [LOW_PRIORITY] [QUICK] [IGNORE] tbl_name[.*] [, tbl_name[.*]] ... FROM table_references [WHERE where_condition] &lt;!-- 多表操作2 --&gt;DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name[.*] [, tbl_name[.*]] ... USING table_references [WHERE where_condition] TRUNCATE TABLE 语法1TRUNCATE [TABLE] tbl_name DELETE 和 TRUNCATE TABLE 的区别现在我们了解了 DELETE 和 TRUNCATE TABLE 的共同点和语法后，现在我们来了解一下它们的区别。DELETE 和 TRUNCATE TABLE 的最大区别在于执行速度和是否可以条件删除。DELETE 可以通过 WHERE 条件来筛选需要删除的记录，且可以返回删除的记录数。TRUNCATE TABLE 不能条件筛选需要删除的记录，且不返回删除的记录数。TRUNCATE TABLE 的执行速度非常快，DELETE 的执行速度不是很快。 未完待续。。。","categories":[{"name":"Java 编程","slug":"Java-编程","permalink":"http://blog.xueni.ren/categories/Java-编程/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.xueni.ren/tags/MySQL/"}],"keywords":[{"name":"Java 编程","slug":"Java-编程","permalink":"http://blog.xueni.ren/categories/Java-编程/"}]},{"title":"Spring 定时器的两种简单实现","slug":"spring-task","date":"2016-09-27T06:55:00.000Z","updated":"2016-11-04T09:08:15.341Z","comments":true,"path":"2016/09/27/spring-task/","link":"","permalink":"http://blog.xueni.ren/2016/09/27/spring-task/","excerpt":"前段时间参与的项目，有一个定时作业来定时的拉取数据。最近得空整理一下我所了解的基于 Spring 的定时器的两种简单实现。","text":"前段时间参与的项目，有一个定时作业来定时的拉取数据。最近得空整理一下我所了解的基于 Spring 的定时器的两种简单实现。 Spring 定时任务基于 XMLSpring 定时任务基于 XML 的实现正是在我们项目中应用的。Spring3.0 以后自带的 task 大大的方便了我们的实现定时任务。 定时任务类12345public class Task01 &#123; public void printJob()&#123; System.out.println(\"************定时打印---XML**************\"); &#125;&#125; 就是一个普通的类，其中，printJob() 是我们需要定时执行的任务方法。 XML12345678910111213141516171819202122232425262728293031323334353637&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xmlns:tool=\"http://www.springframework.org/schema/tool\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xmlns:lang=\"http://www.springframework.org/schema/lang\" xmlns:task=\"http://www.springframework.org/schema/task\" xmlns:cache=\"http://www.springframework.org/schema/cache\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tool http://www.springframework.org/schema/tool/spring-tool.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd\"&gt; &lt;task:annotation-driven /&gt; &lt;!-- 定时任务（每隔5秒执行一次） --&gt; &lt;bean id=\"Task01\" class=\"com.apple.springmvc.task.Task01\"&gt;&lt;/bean&gt; &lt;task:scheduled-tasks&gt; &lt;task:scheduled ref=\"Task01\" method=\"printJob\" cron=\"*/5 * * * * ?\" /&gt; &lt;/task:scheduled-tasks&gt;&lt;/beans&gt; 在 XML 里我们可以设置定时任务的执行频率或者执行时间，关于定时任务 cron 的语法可以参照我之前的一篇博客，定时器语法来修改成符合成你业务需求的。 Spring 定时任务基于注解因为用的 Spring 框架，其实基于注解来实现定时任务相对来说方便很多。 定时任务类1234567@Component(\"task\")public class Task02 &#123; @Scheduled(cron = \"*/7 * * * * ?\") public void printJob2() &#123; System.out.println(\"************定时打印---注解**************\"); &#125;&#125; 这里我们主要用到了两个注解 @Component 和 @Scheduled 。 XML12345678910111213141516171819202122232425262728293031&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xmlns:tool=\"http://www.springframework.org/schema/tool\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xmlns:lang=\"http://www.springframework.org/schema/lang\" xmlns:task=\"http://www.springframework.org/schema/task\" xmlns:cache=\"http://www.springframework.org/schema/cache\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tool http://www.springframework.org/schema/tool/spring-tool.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd\"&gt; &lt;task:annotation-driven /&gt; &lt;context:component-scan base-package=\"com.apple.springmvc.task\"/&gt;&lt;/beans&gt; 以上就是 Spring-task 的两种简单实现，因为代码很简单，就不做过多解释了。","categories":[{"name":"Java 编程","slug":"Java-编程","permalink":"http://blog.xueni.ren/categories/Java-编程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.xueni.ren/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.xueni.ren/tags/Spring/"}],"keywords":[{"name":"Java 编程","slug":"Java-编程","permalink":"http://blog.xueni.ren/categories/Java-编程/"}]},{"title":"通过 HashMap 实现本地缓存","slug":"custom-local-cache","date":"2016-09-22T12:30:00.000Z","updated":"2016-11-04T09:08:15.337Z","comments":true,"path":"2016/09/22/custom-local-cache/","link":"","permalink":"http://blog.xueni.ren/2016/09/22/custom-local-cache/","excerpt":"引言 本地缓存在我们的工作中是比较常见的一种技术手段，不管是分布式缓存，还是本地缓存，或多或少我们都会使用到，本地缓存比较常用的数 Guava 缓存。今天我们不聊 Guava，而是聊一聊怎样通过 HashMap 来实现一个本地缓存。","text":"引言 本地缓存在我们的工作中是比较常见的一种技术手段，不管是分布式缓存，还是本地缓存，或多或少我们都会使用到，本地缓存比较常用的数 Guava 缓存。今天我们不聊 Guava，而是聊一聊怎样通过 HashMap 来实现一个本地缓存。 实现通过 HashMap 实现本地缓存相当简单，废话不多说，先上代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public enum UserCache &#123; instance; // 日志记录器 private final static org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(UserCache.class); HashMap&lt;Integer, String&gt; UserMap = new HashMap&lt;&gt;(); static &#123; UserCache.instance.init(); &#125; /** * 初始化缓存 * */ public void init() &#123; log.info(\"初始化 User 缓存初始化开始...\"); // web容器中获取上下文 WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext(); IUserDao UserDao = (IUserDao) context.getBean(\"UserDaoImpl\"); List&lt;User&gt; Users = UserDao.selectAll(); int count = 0; for (User User : Users) &#123; count++; UserMap.put(User.getUserId(), JSON.toJSONString(User)); &#125; if (Users.size() != count) &#123; log.error(\"User 数据未完全加载！\"); &#125; log.info(\"共计加载：\" + count); log.info(\"初始化 User 缓存初始化结束！\"); &#125; public HashMap&lt;Integer, String&gt; getPhoneAttr() &#123; return UserMap; &#125;&#125; 代码是不是相当简单，聪明的你一定能看懂这段代码。那么，请聪明的你再猜猜，我是怎么刷新缓存的？对了，就是定时器，用定时器去定时的刷新缓存。整个设计跟实现是不是都很简单啊？","categories":[{"name":"Java 编程","slug":"Java-编程","permalink":"http://blog.xueni.ren/categories/Java-编程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.xueni.ren/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"http://blog.xueni.ren/tags/HashMap/"}],"keywords":[{"name":"Java 编程","slug":"Java-编程","permalink":"http://blog.xueni.ren/categories/Java-编程/"}]},{"title":"深入理解 Java 虚拟机 读书笔记","slug":"JVM-read-notes","date":"2016-08-09T15:15:00.000Z","updated":"2016-11-04T09:08:15.337Z","comments":true,"path":"2016/08/09/JVM-read-notes/","link":"","permalink":"http://blog.xueni.ren/2016/08/09/JVM-read-notes/","excerpt":"在早之前，曾粗略的读过一次 《深入理解 Java 虚拟机》这边书，那时候，是在每天上下班路上在公交车上用 kindle 阅读。由于阅读体验并不怎么好，所以收获并不大。由于同事极力推荐这本书，于是，果断入手了一本纸质版。这次通过这次阅读，收获不小。（看来，技术类的书还是要看纸质的，电子版阅读体验太差。）废话少说，开始正题。","text":"在早之前，曾粗略的读过一次 《深入理解 Java 虚拟机》这边书，那时候，是在每天上下班路上在公交车上用 kindle 阅读。由于阅读体验并不怎么好，所以收获并不大。由于同事极力推荐这本书，于是，果断入手了一本纸质版。这次通过这次阅读，收获不小。（看来，技术类的书还是要看纸质的，电子版阅读体验太差。）废话少说，开始正题。 Java 虚拟机Java 虚拟机简称 JVM.","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.xueni.ren/categories/读书笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.xueni.ren/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://blog.xueni.ren/tags/JVM/"}],"keywords":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.xueni.ren/categories/读书笔记/"}]},{"title":"定时器语法","slug":"timer-grammar-xml","date":"2016-07-14T23:00:00.000Z","updated":"2016-11-04T09:08:15.341Z","comments":true,"path":"2016/07/15/timer-grammar-xml/","link":"","permalink":"http://blog.xueni.ren/2016/07/15/timer-grammar-xml/","excerpt":"日常工作中我们经常会实现这样一些功能，比如定时删除或者下载文件等等。首先我们想到的就是通过一个定时器定时的帮助我们去干一些我们需要它们帮助我们做的事情。","text":"日常工作中我们经常会实现这样一些功能，比如定时删除或者下载文件等等。首先我们想到的就是通过一个定时器定时的帮助我们去干一些我们需要它们帮助我们做的事情。下面我们就了解一下，一些常用的定时器语法。 字段 允许值 允许的特殊符号 秒 0-59 - * / 分 0-59 - * / 小时 0-23 - * / 日期 1-31 - * ? / L W C 月份 1-12或者JAN-DEC - * / 星期 1-7或者SUN-SAT - * ? / L C # 年（可选） 留空，1970-2099 - * / 一些常用的示例：1234567891011121314151617181920212223242526 &quot;0 0 12 * * ?&quot; 每天中午12点触发&quot;0 15 10 ? * *&quot; 每天上午10:15触发&quot;0 15 10 * * ?&quot; 每天上午10:15触发&quot;0 15 10 * * ? * &quot; 每天上午10:15触发&quot;0 15 10 * * ? 2005 &quot; 2005年的每天上午10:15触发&quot;0 * 14 * * ? &quot; 每天下午2点到2点59期间的每一分钟触发&quot;0 0/5 14 * * ? &quot; 每天下午2点到2点55期间的每5分钟触发&quot;0 0/5 14,18 * * ? &quot; 每天下午2点到2点55期间和下午6点到6点55期间的每5分钟触发&quot;0 0-5 14 * * ? &quot; 每天下午2点到2点5分期间的每1分钟触发&quot;0 10,44 14 ? 3 WED &quot; 每年三月的星期三的下午2:10和2:44分触发&quot;0 15 10 ? * MON-FRI &quot; 周一至周五的上午10:15触发&quot;0 15 10 15 * ? &quot; 每月15日上午10:15触发&quot;0 15 10 L * ? &quot; 每月最后一日上午10:15触发&quot;0 15 10 ? * 6L &quot; 每月最后一个星期五上午10:15触发&quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年每月最后一个星期五上午10:15触发&quot;0 15 10 ? * 6#3 &quot; 每月的第三个星期五上午10:15触发每隔5秒执行一次：*/5 * * * * ? 每隔1分钟执行一次：0 */1 * * * ? 每天23点执行一次：0 0 23 * * ? 每天凌晨1点执行一次：0 0 1 * * ? 每月1号凌晨1点执行一次：0 0 1 1 * ? 每月最后一天23点执行一次：0 0 23 L * ? 每周星期天凌晨1点实行一次：0 0 1 ? * L 在26分、29分、33分执行一次：0 26,29,33 * * * ? 每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.xueni.ren/categories/学习笔记/"}],"tags":[{"name":"timer","slug":"timer","permalink":"http://blog.xueni.ren/tags/timer/"},{"name":"xml","slug":"xml","permalink":"http://blog.xueni.ren/tags/xml/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.xueni.ren/categories/学习笔记/"}]},{"title":"Google Guava Cache 学习笔记","slug":"google-guava","date":"2016-06-14T16:00:00.000Z","updated":"2016-11-04T09:08:15.341Z","comments":true,"path":"2016/06/15/google-guava/","link":"","permalink":"http://blog.xueni.ren/2016/06/15/google-guava/","excerpt":"缓存缓存主要作用是就是预读取（预先读取将要载入的数据）、存储临时访问过的数据和对写入的数据进行暂时存放。","text":"缓存缓存主要作用是就是预读取（预先读取将要载入的数据）、存储临时访问过的数据和对写入的数据进行暂时存放。 比较常见的几种缓存 本地缓存 分布式缓存 数据库缓存 CPU 缓存 Http 缓存 Guava CacheGuava Cache 是一个全内存的本地缓存，它提供了线程安全的实现机制。使用缓存就意味着你要牺牲一部分内存空间。 Guava Cache 有两种创建方式CacheLoaderLoadingCache 是附带 CacheLoader 构建而成的缓存实现，创建自己的 CacheLoader 通常只需要简单的实现 V load(K key) throws Exception 方法。官网的范例如下： 123456789101112131415LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder() .maximumSize(1000) .build( new CacheLoader&lt;Key, Graph&gt;() &#123; public Graph load(Key key) throws AnyException &#123; return createExpensiveGraph(key); &#125; &#125;); ...try &#123; return graphs.get(key);&#125; catch (ExecutionException e) &#123; throw new OtherException(e.getCause());&#125; 参照官网的范例，我的测试代码如下： 123456789101112131415161718192021222324252627private LoadingCache&lt;String,List&lt;User&gt;&gt; cache = null; @Before public void loadCache()&#123; cache = CacheBuilder .newBuilder() .maximumSize(1000) .expireAfterAccess(2, TimeUnit.SECONDS) .build(new CacheLoader&lt;String, List&lt;User&gt;&gt;() &#123; @Override public List&lt;User&gt; load(String key) throws Exception &#123; return userService.getAllUser(); &#125; &#125;); &#125; @Test public void testLoadingCache()&#123; try &#123; System.out.println(cache.get(\"user\")); System.out.println(cache.get(\"user\")); Thread.sleep(5000);//这里主要是为了测试expireAfterAccess(2, TimeUnit.SECONDS) System.out.println(cache.get(\"user\")); System.out.println(cache.get(\"user\")); &#125; catch (Exception e) &#123; System.out.println(\"---\"+e.getMessage()); &#125; &#125; 从 LoadingCache 查询的正规方式是试用 get(k) 方法。这个方法要么返回已经缓存的值，要么使用 CacheLoader 向缓存原子地加载新值。由于 CacheLoader 可能抛出异常，LoadingCache.get(k) 也声明为抛出 ExecutionException 异常。如果你定义的 CacheLoader 没有声明任何检查型异常，则可通过 getUnchecked(k) 查找缓存，但必须注意，一旦 CacheLoader 声明了检查异常，就可以不调用 getUnchecked(k)。官网示例： 1234567891011LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder() .expireAfterAccess(10, TimeUnit.MINUTES) .build( new CacheLoader&lt;Key, Graph&gt;() &#123; public Graph load(Key key) &#123; // no checked exception return createExpensiveGraph(key); &#125; &#125;); ...return graphs.getUnchecked(key); Callable所有类型的 Guava Cache ，不管有没有自动加载功能，都支持 get(K,Callable&lt;V&gt;) 方法。这个方法返回缓存中相应的值，或者用给定的 Callable 运算并把结果加到缓存中。在整个加载方法完成前，缓存项相关的可观察状态都不会更改。这个方法简便第实现了模式 “如果有缓存则返回；否则运算、缓存、然后返回”。官网示例： 1234567891011121314151617Cache&lt;Key, Graph&gt; cache = CacheBuilder.newBuilder() .maximumSize(1000) .build(); // look Ma, no CacheLoader...try &#123; // If the key wasn't in the \"easy to compute\" group, we need to // do things the hard way. cache.get(key, new Callable&lt;Key, Graph&gt;() &#123; @Override public Value call() throws AnyException &#123; return doThingsTheHardWay(key); &#125; &#125;);&#125; catch (ExecutionException e) &#123; throw new OtherException(e.getCause());&#125; 参照官网的范例，我的测试代码如下： 123456789101112131415161718192021222324private Cache&lt;String,List&lt;User&gt;&gt; cache = null; private List&lt;User&gt; users = null; @Before public void callableCache()&#123; cache = CacheBuilder.newBuilder().maximumSize(1000).build(); try &#123; users = cache.get(\"user\", new Callable&lt;List&lt;User&gt;&gt;() &#123; public List&lt;User&gt; call() throws Exception &#123; return userService.getAllUser(); &#125; &#125;); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testCallableCache() throws Exception&#123; System.out.println(\"user value : \" + users); System.out.println(\"user value : \" + users); System.out.println(\"user value : \" + users); System.out.println(\"user value : \" + users); &#125; 使用 cache.put(key,value) 方法可以直接向缓存中插入值，这回直接覆盖掉给定键之前映射的值。使用 Cache.asMap() 视图提供的任何方法也能修改缓存。但请注意，asMap 视图的任何方法都不能保证缓存项被院子地加载到缓存中。进一步说，asMap 视图的原子运算在 Guava Cache 的原子加载范畴之外，所以相比于 Cache.asMap().putIfAbsent(K,V), Cache.get(K,Callable&lt;K&gt;) 应该总是优先使用。 Cache 参数说明：回收的参数： 基于容量的回收(size-based eviction) CacheBuilder.maximumSize(long):如果要规定缓存项的数据不超过固定值，只需要设置该参数。缓存将尝试回收最近没有使用或总体上很少使用的缓存项。警告：在缓存项的数目达到限定值之前，缓存就可能进行回收操作，通常来说，这种情况发生在缓存项的数目逼近限定值时。 CacheBuilder.weigher(Weigher):不同的缓存项有不同的 “权重” (weights). 例如，如果你的缓存值，占据完全不同的内存空间可以设置该参数指定一个权重函数，并用 CacheBuilder.maxumumWeigher(long) 指定最大总重。 CacheBuilder.maxumumWeigher(long):指定权重最大总重。在权重限定场景中，除了要注意回收也是在冲了逼近限定值时就进行了，还要知道重量是在缓存创建时计算的，因此要考虑重量计算的复杂度。 定时回收(Timed Eviction) expireAfterAccess(long, TimeUnit):缓存项在给定时间内没有被读/写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。 expireAfterWrite(long, TimeUnit):缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候会变得陈旧不可用，这种回收方式是可取的。引用的回收(Reference-based Eviction)通过使用弱引用的键、或弱引用的值、或软引用的值，Guava Cache 可以把缓存设置为允许垃圾回收： CacheBuilder.weakKeys():使用弱引用存储键，当键没有其它（强或软）引用时，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式（==），使用弱医用建的缓存用 == 而不是 equals 比较键。 CacheBuilder.weakValues():使用弱引用存储值。当值没有其它（强或软）引用是，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式（==）而不是 equals 比较值。 CacheBuilder.softValues():使用软引用存储值。软引用只有在响应内存需要是，才按照全局最近最少使用的顺序回收。考虑到使用软引用的性能影响。我们通常建议使用更有性能预测性的缓存大小限定。使用软引用值的缓存同样用 == 而不是 equals 比较值。 显式清除任何时候，你都可以显式地清除缓存项，而不是等到它被回收： Cache.invalidate(key):个别清除。 Cache.invalidateAll(keys):批量清除。 Cache.invalidateAll():清除所有缓存项。 移除监听器 CacheBuilder.removalListener(RemovalListener):通过 CacheBuilder.removalListener(RemovalListener) 可以声明一个监听器，一边缓存项被移除是做一些额外操作。缓存项被移除是，RemovalListener 会获取移除通知 RemovalNotification,其中包含移除原因 RemovalCause、键和值。请注意，RemovalListener 抛出的任何异常都会记录到日志后被丢弃 swallowed 。 参考资料","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.xueni.ren/categories/学习笔记/"}],"tags":[{"name":"Java 编程","slug":"Java-编程","permalink":"http://blog.xueni.ren/tags/Java-编程/"},{"name":"Guava","slug":"Guava","permalink":"http://blog.xueni.ren/tags/Guava/"},{"name":"Cache","slug":"Cache","permalink":"http://blog.xueni.ren/tags/Cache/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.xueni.ren/categories/学习笔记/"}]},{"title":"BufferedReader.readLine() 的使用中遇到的问题","slug":"BufferedReader-readLine","date":"2016-06-13T14:15:00.000Z","updated":"2016-11-04T09:08:15.337Z","comments":true,"path":"2016/06/13/BufferedReader-readLine/","link":"","permalink":"http://blog.xueni.ren/2016/06/13/BufferedReader-readLine/","excerpt":"前言遇到这么一个问题，需要从网络上下载图片到本地，单元测试一直停不下来，有次让单元测试跑起来之后，自己出去吃了个早饭回来发现单元测试还没有跑完。然后跟断点发现程序阻塞在 readLine() 方法上了。","text":"前言遇到这么一个问题，需要从网络上下载图片到本地，单元测试一直停不下来，有次让单元测试跑起来之后，自己出去吃了个早饭回来发现单元测试还没有跑完。然后跟断点发现程序阻塞在 readLine() 方法上了。 BufferedReaderBufferedReader 是由 Reader 类扩展而来，提供通用的缓冲方式文本读取，而且提供了很实用的 readLine 方法，也就是今天我要重点说的那个方法。BufferReader 的作用是为 Reader 提供缓冲功能。 readLine 方法一次读取一个文本行，从字符输入流中读取文本，缓冲各个字符，从而提供字符、数组和行的高效读取。 1234567StringBuffer sb = new StringBuffer(); BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line = null; while ((line = reader.readLine()) != null) &#123; System.out.println(¨---here¨); sb.append(line); &#125; 然后程序就阻塞在了 while ((line = reader.readLine()) != null) 这一行。System.out.println(¨—here¨); 这一句始终没有打印。 那么，程序为什么会阻塞呢？那么我们就需要了解一下 readLine 这个方法了。readLine 是一个阻塞方法，在没有读取到数据的时候并不会返回 null 。readLine 只有在数据流发生异常时才会返回null值。如果不指定 buffer 大小，则 readLine 的 buffer 默认大小是 8192 个字符。在没有达到buffer大小之前，只有遇到“/r”、”/n”、”/r/n”才会返回。这个时候这个时候，我就在猜想到底是我的图片太小，不足 8192 个字符呢？还是说别的什么原因才导致 readLine 才没有一直返回。。为了不让程序阻塞，可以设置超时时间，但是这个不是解决问题的最终办法。因为这个 url 上的图片通过浏览器是可以正常访问，且完全可以通过浏览器下载到本地。断点一路跟来，最后锁定问题出在了这一句 conn.getInputStream() 因为 InputStream 流的原因，导致 readine 读不到数据才一直阻塞 InputStream 我是通过一下方式获取的。12345678HttpURLConnection conn = (HttpURLConnection) new URL(picURL).openConnection(); conn.setRequestProperty(\"Accept-Charset\", \"utf-8\"); conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); conn.setConnectTimeout(timeout * 1000); conn.setReadTimeout(timeout * 1000); return conn.getInputStream(); 看代码似乎没有什么问题，但是通过在控制台打印我发现来，conn.getContentEncoding() 的值为 null 和 gzip 的会导致 readLine 阻塞。这个时候问题就有两种解决方案了一种是，在返回 InputStream 流的时候进行类型判断，还有一种方案就是换一种图片下载的方式。 总结 通过在网上查资料，大多数人都建议在使用socket之类的数据流时，要避免使用 readLine。 conn.getInputStream() 有可能会获取到 gzip 流，我们可以通过 new GZIPInputStream(conn.getInputStream()) 来解压我们的流。","categories":[{"name":"Java 编程","slug":"Java-编程","permalink":"http://blog.xueni.ren/categories/Java-编程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.xueni.ren/tags/Java/"}],"keywords":[{"name":"Java 编程","slug":"Java-编程","permalink":"http://blog.xueni.ren/categories/Java-编程/"}]},{"title":"SpringMVC 整合Mongodb","slug":"spring-data-mongodb","date":"2016-06-06T14:27:45.000Z","updated":"2016-11-04T09:08:15.341Z","comments":true,"path":"2016/06/06/spring-data-mongodb/","link":"","permalink":"http://blog.xueni.ren/2016/06/06/spring-data-mongodb/","excerpt":"引言平时都在用 SpringMVC 进行开发，但是，基本上都是在用 SpringMVC+Mybatis+MySQL 进行开发。对于 Mongodb 只是听说过，自己实际没有操作过，近期，在工作之余决定研究一下 Mongodb 。","text":"引言平时都在用 SpringMVC 进行开发，但是，基本上都是在用 SpringMVC+Mybatis+MySQL 进行开发。对于 Mongodb 只是听说过，自己实际没有操作过，近期，在工作之余决定研究一下 Mongodb 。那么，开始进入正题吧，此次我构建的项目是 SpringMVC+Mongodb+Maven ，有不对之处，还望指出。 作为一个 Maven 工程，我们还是先从 pom.xml 文件开始把,在 pom.xml 里配置我们的工程所依赖的 jar。pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.apple&lt;/groupId&gt; &lt;artifactId&gt;MongoDemo&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;MongoDemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 属性配置 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;jdk.version&gt;1.7&lt;/jdk.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring4支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-data-mongodb --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-mongodb&lt;/artifactId&gt; &lt;version&gt;1.7.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mongodb 驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- WEB --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!-- 编译需要而发布不需要的jar包 --&gt; &lt;/dependency&gt; &lt;!-- 阿里JSON包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j2核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 项目构建配置 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 资源 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 编译 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;$&#123;jdk.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;jdk.version&#125;&lt;/target&gt; &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;optimize&gt;true&lt;/optimize&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 发布 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;warName&gt;/&lt;/warName&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 接着就是web.xml 文件，有一点我们需要明确的就是， web.xml 文件并不是 web 工程所必须的，但是，一般情况下，我们都是以 web.xml 作为我们 web工程的入口。web.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:spring/applicationContext-dao.xml, classpath:spring/applicationContext-service.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.json&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsonp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.json&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsonp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt;``` db.properties 文件```xmlmongo.host=127.0.0.1mongo.port=27017mongo.username=mongo.password=mongo.database=test applicationContext-mvc.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xmlns:tool=\"http://www.springframework.org/schema/tool\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xmlns:lang=\"http://www.springframework.org/schema/lang\" xmlns:task=\"http://www.springframework.org/schema/task\" xmlns:cache=\"http://www.springframework.org/schema/cache\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tool http://www.springframework.org/schema/tool/spring-tool.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd\"&gt; &lt;!-- 扫描包 --&gt; &lt;context:component-scan base-package=\"com.apple.mongo.controller\" /&gt; &lt;!-- 这个配置用于返回json或者jsonp,具体的序列化器可以自定义 --&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"false\"&gt; &lt;!-- 注意：不设置为false的话存在性能问题差1倍 --&gt; &lt;bean class=\"web.converter.RestResponseMessageConverter\"&gt; &lt;property name=\"features\"&gt; &lt;array&gt; &lt;util:constant static-field=\"com.alibaba.fastjson.serializer.SerializerFeature.QuoteFieldNames\" /&gt;&lt;!-- 输出key时是否使用双引号,默认为true --&gt; &lt;util:constant static-field=\"com.alibaba.fastjson.serializer.SerializerFeature.WriteMapNullValue\" /&gt;&lt;!-- 是否输出值为null的字段,默认为false --&gt; &lt;util:constant static-field=\"com.alibaba.fastjson.serializer.SerializerFeature.WriteEnumUsingToString\" /&gt; &lt;util:constant static-field=\"com.alibaba.fastjson.serializer.SerializerFeature.SkipTransientField\" /&gt; &lt;util:constant static-field=\"com.alibaba.fastjson.serializer.SerializerFeature.WriteDateUseDateFormat\" /&gt; &lt;util:constant static-field=\"com.alibaba.fastjson.serializer.SerializerFeature.DisableCheckSpecialChar\" /&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 启动Spring MVC的注解功能，完成请求和注解POJO的映射,解决@ResponseBody乱码问题, 需要在annotation-driven之前,否则乱码问题同样无法解决 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.http.MediaType\"&gt; &lt;constructor-arg index=\"0\" value=\"text\" /&gt; &lt;constructor-arg index=\"1\" value=\"plain\" /&gt; &lt;constructor-arg index=\"2\" value=\"UTF-8\" /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 视图 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\" /&gt;&lt;!-- 前缀路径 --&gt; &lt;property name=\"suffix\" value=\"\" /&gt;&lt;!-- 后缀 --&gt; &lt;/bean&gt;&lt;/beans&gt; applicationContext-dao.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:task=\"http://www.springframework.org/schema/task\" xmlns:mongo=\"http://www.springframework.org/schema/data/mongo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd http://www.springframework.org/schema/data/mongo http://www.springframework.org/schema/data/mongo/spring-mongo-1.7.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.1.xsd\"&gt; &lt;context:annotation-config /&gt; &lt;!-- 提供该PropertyPlaceholderConfigurer bean支持把properties文件中的信息读取到XML配置文件的表达式中 --&gt; &lt;context:property-placeholder location=\"classpath:conf/db.properties\" /&gt; &lt;!-- 通过工厂Bean创建mongo连接实例,没有密码就把username和password属性删除了--&gt; &lt;mongo:db-factory host=\"$&#123;mongo.host&#125;\" port=\"$&#123;mongo.port&#125;\" dbname=\"$&#123;mongo.database&#125;\" /&gt; &lt;!-- mongo模板操作对象 --&gt; &lt;bean id=\"mongoTemplate\" class=\"org.springframework.data.mongodb.core.MongoTemplate\"&gt; &lt;constructor-arg name=\"mongoDbFactory\" ref=\"mongoDbFactory\"/&gt; &lt;/bean&gt; &lt;!-- MongoDB GridFS Template 支持，操作mongodb存放的文件 --&gt; &lt;mongo:mapping-converter id=\"converter\" db-factory-ref=\"mongoDbFactory\"/&gt; &lt;bean id=\"gridFsTemplate\" class=\"org.springframework.data.mongodb.gridfs.GridFsTemplate\"&gt; &lt;constructor-arg ref=\"mongoDbFactory\"/&gt; &lt;constructor-arg ref=\"converter\"/&gt; &lt;/bean&gt; &lt;!-- 使用annotation定义事务 &lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt; --&gt; &lt;!-- 扫描实现 --&gt; &lt;context:component-scan base-package=\"com.apple.mongo.dao.impl\" /&gt;&lt;/beans&gt; applicationContext-service.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xmlns:tool=\"http://www.springframework.org/schema/tool\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xmlns:lang=\"http://www.springframework.org/schema/lang\" xmlns:task=\"http://www.springframework.org/schema/task\" xmlns:cache=\"http://www.springframework.org/schema/cache\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tool http://www.springframework.org/schema/tool/spring-tool.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd \"&gt; &lt;!-- 该配置文件主要针对service层(服务层)做配置 --&gt; &lt;context:component-scan base-package=\"com.apple.mongo.service\" resource-pattern=\"**/*ServiceImpl.class\" /&gt;&lt;/beans&gt;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.xueni.ren/categories/学习笔记/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://blog.xueni.ren/tags/SpringMVC/"},{"name":"整合Mongod","slug":"整合Mongod","permalink":"http://blog.xueni.ren/tags/整合Mongod/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.xueni.ren/categories/学习笔记/"}]},{"title":"Java 并发编程读书笔记(基础篇)","slug":"Java-compli-read-notes-basis","date":"2016-06-01T15:15:45.000Z","updated":"2016-11-04T09:08:15.337Z","comments":true,"path":"2016/06/01/Java-compli-read-notes-basis/","link":"","permalink":"http://blog.xueni.ren/2016/06/01/Java-compli-read-notes-basis/","excerpt":"基础篇，从各种概念开始。线程安全 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步货协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。","text":"基础篇，从各种概念开始。线程安全 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步货协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。 在线程安全类中封装来必要的同步机制，因此客户端无须进一步采取同步措施。 无状态对象一定是线程安全的。在并发编程中，这种由于不恰当的执行时序而出现的不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件。 原子操作作为一个不可分割的操作来执行。我们所熟知的 ++i 并不是一个原子操作，它实际上是一个 *¨读取 i 值 – 修改 i 值 – 写入 i 值¨ 的操作序列，并且其结果依赖于之前的状态。 内置锁每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为内置锁(Inteinsic Lock)或者监视器锁(Monitor Lock)。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。Java 的内置锁相当于一种互斥体(互斥锁)，这意味着最多只有一个线程能持有这种锁。 重入当某个线程请求一个由其他线程持有的锁是，发出请求的线程就会阻塞。¨重入¨ 意味着获取锁的操作的粒度是¨线程¨，而不是¨调用¨。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。 Volatile 关键字Java 语言提供来一种弱同步机制，即 volatile 变量，用来确保变量的更新操作通知到其他线程。仅当 volatile 变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用 volatile 变量。volatile 变量的正确使用方式包括：确保它们自身状态的可见性，确保它们锁引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生。 发布与逸出发布一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他对象，那么这些对象也都会被发布。当某个不应该发布的对象被发布时，就称为逸出。 线程封闭线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由该线程修改。 Ad-hoc 线程封闭Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。 栈封闭栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。栈封闭比 Ad-hoc 线程封闭更易于维护，也更健壮。 ThreadLocal 类维持线程封闭性的一种更规范方法是使用 ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 对象通常用于防止对可变的单实例变量或全局变量进行共享。 不变性如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。不可变对象一定是线程安全的。 当满足一下条件时，对象才是不可变的： 对象创建以后其状态就不能被修改。 对象的所有域都是 final 类型。 对象是正确创建的(在对象创建期间，this 引用没有逸出)。 Final 域final 域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无须同步。 要安全地发布一个对象，对象的引用以及对象的状态必须同事对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布： 在静态初始化函数中初始化一个对象引用。 将对象的引用保存到 olatile 类型的域或者 AtomicReferance 对象中。 将对象的引用保存到某个正确构造对象的 final 类型域中。 将对象的引用保存到一个由锁保护的域中。 线程安全库中的容器类提供以下安全发布保证： 通过将一个键或者值放入 Hashtable、sychronziedMap 或者 ConcurrentMap 中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。 通过将某个元素放入 Vector、CopyOnWriteArrayList、CopyWriteArraySet、synchronizedist 或 synchroizedSet 中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。 通过将某个元素放入 BlockingQueue 或者 ConcurrentLinkedQueue 中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。 对象的发布需求取决于它的可变性： 不可变对象可以通过任意机制来发布。 事实不可变对象必须通过安全方式来发布。 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。 在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：线封闭 线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。只读共享 在没有额外同步的情况下，共享的只对对象可以由多个线程并发访问，但任何线程都不能修改它。共享只读对象包括不可变对象和事实不可变对象。线程安全共享 线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。保护对象 被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且有某个特定锁保护的对象。 在设计线程安全类的过程中，需要包含一下三个基本要素： 找出构成对象状态的所有变量。 找出约束状态变量的不变性条件。 建立对象状态的并发访问管理策略。 小结 可变状态是至关重要的。所有的并发问题都可以归结为如何协调对并发状态的访问。可变状态越少，就越容易确保线程的安全性。 尽量将域声明为 final 类型，除非需要它们是可变的。 不可变对象一定是线程阿安全的。不可变对象能极大地降低并发编程到的复杂性。它们更为简单而且安全，可以任意共享而无须使用加锁或保护性复制等机制。 封装有助于管理复杂性。将数据封装在对象中，更易于维持不变性条件，将同步机制封装在对象中，更易于遵循同步策略。 用锁来保护每个可变变量。 当保护用一个不变性条件中的所有变量时，要使用同一个锁。 在执行符合操作期间，要持有锁。 如果从多线程中访问同一个可变变量时没有同步机制，那么程序会出现问题。 不要故作聪明地推断出不需要使用同步。 在设计过程中考虑线程安全，或者文档中明确指出它不是线程安全的。 将同步策略文档化。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.xueni.ren/categories/读书笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.xueni.ren/tags/Java/"}],"keywords":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.xueni.ren/categories/读书笔记/"}]},{"title":"MySQL 入库操作的优化","slug":"MySQL-batch-insert","date":"2016-06-01T14:22:22.000Z","updated":"2016-11-04T09:08:15.337Z","comments":true,"path":"2016/06/01/MySQL-batch-insert/","link":"","permalink":"http://blog.xueni.ren/2016/06/01/MySQL-batch-insert/","excerpt":"最近开始玩 MyBatis ，想实现这么一个功能，就是将一张表里的数据作为历史数据存储到另一张表里去。一开始我的代码是这么写的：","text":"最近开始玩 MyBatis ，想实现这么一个功能，就是将一张表里的数据作为历史数据存储到另一张表里去。一开始我的代码是这么写的： 1234567List&lt;BookHistory&gt; bookHistories = bookHisDao.getBookList();//获取需要存储的历史数据for (BookHistory BookHistory:bookHistories) &#123; BookHistory book = bookHisDao.selectBookById(BookHistory); if(null == book)&#123; bookHisDao.insertBook(bookHistory);// 数据入库操作 &#125;&#125; 看起来简单粗暴，似乎没有什么问题，查询出来一个list，然后循环遍历，检查是否已经存在历史库中，如果不存在则入库。功能也正确实现，但是，存在的问题是，速度有点太慢。2007 条数据的执行时间是 2m 1s 505ms 。对于追求完美的我，这是不能忍受的，首先我能想到的就是优化入库操作，因为一条数据一条数据的插入，确实会速度特别慢，说干就干，首先先将入库操作由原来的一条一条入库改成批量入库。接下来我的代码变成了这样： 1234567891011List&lt;BookHistory&gt; bookHistories = bookHisDao.getBookList();Iterator&lt;BookHistory&gt; bookIter= bookHistories.iterator();while (bookIter.hasNext())&#123; BookHistory bookHistory = bookIter.next(); BookHistory book = bookHisDao.selectBookById(bookHistory); if(null != book)&#123; bookIter.remove(); &#125;&#125;int count = bookHisDao.insertBookBatch(bookHistories);//批量入库操作System.out.println(\"insert \"+count+\" records\"); 改成批量入库操作后，速度直线上升，2007条数据的执行时间是 6s 737ms ，现在看来，情况很乐观，但是随之而来的又出来了另一个问题，因为做测试，我并没有将所有字段都进行入库操作。 当我把字段补齐时，控制台报了这样一个错： 123org.springframework.dao.TransientDataAccessResourceException: ### Error updating database. Cause: com.mysql.jdbc.PacketTooBigException: Packet for query is too large (13513737 &gt; 4194304). You can change this value on the server by setting the max_allowed_packet&apos; variable.### The error may involve BookHistory.insertBookBatch-Inline 看到控制台提到了 max_allowed_packet 这个参数，那么我们就需要了解一下，这个参数是干什么用的。max_allowed_packet 是 MySQL 变量的一个变量，用于控制其通信缓冲区的最大长度。默认值是：4194304.从控制台的报错信息可以看出来，我此时需要的缓冲区长度为：13513737，远大于4194304。最简单粗暴的办法就是修改 MySQL 的 max_allowed_packet 参数。修改这个参数，可以暂时的解决问题，但是不能长久的解决问题，因为我无法保证线上的数据量会是多大。这时候，我需要寻找别的突破点。既然2007条数据同时入库，会导致 MySQL 的缓冲区不够用，那么，我是否可以改一下自己的程序，不让数据一次性都插入，而是，分批插入，比如说每次 500 条数据呢？接下来，我又对我的代码做了如下修改： 123456789101112131415161718192021222324252627List&lt;BookHistory&gt; bookHistories = bookHisDao.getBookList();Iterator&lt;BookHistory&gt; bookIter= bookHistories.iterator();while (bookIter.hasNext())&#123; BookHistory bookHistory = bookIter.next(); BookHistory book = bookHisDao.selectBookById(bookHistory); if(null != book)&#123; bookIter.remove(); &#125;&#125;//int count = bookHisDao.insertBookBatch(bookHistories);//批量入库操作//System.out.println(\"insert \"+count+\" records\");//分批，批量入库操作int batch = 0;List&lt;BookHistory&gt; bookList = new ArrayList&lt;BookHistory&gt;();for (BookHistory bookHistory:bookHistories)&#123; batch++; bookList.add(bookHistory); System.out.println(batch); if (batch == 500)&#123; bookHisDao.insertBookBatch(bookList); System.out.println(bookList.size()); batch = 0; bookList.clear(); &#125;&#125;bookHisDao.insertBookBatch(bookList); 这样一修改之后，控制台的错误消失，程序的运行速度是 8s 393ms 。比刚才的 一次性批量入库慢了 2s 。。。暂时还没有想到更好的解决方案，先这样，我再想想还有么有更好的解决方案。以上的修改，虽然解决了问题，但是代码不够优雅。 最后，我们需要思考的问题是，为什么 MySQL 入库，批量入库比一条一条的数据入库性能好很多？","categories":[{"name":"Java 编程","slug":"Java-编程","permalink":"http://blog.xueni.ren/categories/Java-编程/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.xueni.ren/tags/MySQL/"}],"keywords":[{"name":"Java 编程","slug":"Java-编程","permalink":"http://blog.xueni.ren/categories/Java-编程/"}]},{"title":"test","slug":"test","date":"2015-11-18T16:00:00.000Z","updated":"2016-11-04T09:08:15.341Z","comments":true,"path":"2015/11/19/test/","link":"","permalink":"http://blog.xueni.ren/2015/11/19/test/","excerpt":"md语法","text":"md语法 This is an h1 tagThis is an h2 tagThis is an h6 tagThis text will be italicThis will also be italic This text will be boldThis will also be bold You can combine them Item 1 Item 2 Item 2a Item 2b Item 1 Item 2 Item 3 Item 3a Item 3b As Kanye West said: We’re living the future sothe present is our past. I think you should use an&lt;addr&gt; element here instead. 12345function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; [x] @mentions, #refs, links, formatting, and tags supported [x] list syntax required (any unordered or ordered list supported) [x] this is a complete item [ ] this is an incomplete item First Header Second Header Content from cell 1 Content from cell 2 Content in the first column Content in the second column @octocat :+1: This PR looks great - it’s ready to merge! :shipit:","categories":[{"name":"categories","slug":"categories","permalink":"http://blog.xueni.ren/categories/categories/"}],"tags":[{"name":"test","slug":"test","permalink":"http://blog.xueni.ren/tags/test/"}],"keywords":[{"name":"categories","slug":"categories","permalink":"http://blog.xueni.ren/categories/categories/"}]},{"title":"发布pelican博客","slug":"pelican-blog","date":"2015-03-31T16:00:00.000Z","updated":"2016-11-04T09:08:15.341Z","comments":true,"path":"2015/04/01/pelican-blog/","link":"","permalink":"http://blog.xueni.ren/2015/04/01/pelican-blog/","excerpt":"","text":"没有前言，没有概述，做个笔记而已。 在content目录里新建 .py 文件，写完之后执行pelican content，生成页面。 cd 到output里 执行python -m pelican.server。 localhost:8000 查看效果。 cd到blog的根目录，执行 sh push_to.sh。 最后，记得也要把blog的content也push到github上。","categories":[{"name":"pelican","slug":"pelican","permalink":"http://blog.xueni.ren/categories/pelican/"},{"name":"python","slug":"pelican/python","permalink":"http://blog.xueni.ren/categories/pelican/python/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://blog.xueni.ren/tags/blog/"}],"keywords":[{"name":"pelican","slug":"pelican","permalink":"http://blog.xueni.ren/categories/pelican/"},{"name":"python","slug":"pelican/python","permalink":"http://blog.xueni.ren/categories/pelican/python/"}]},{"title":"Hello World","slug":"hello-world","date":"2014-11-18T16:00:00.000Z","updated":"2016-11-04T09:08:15.341Z","comments":true,"path":"2014/11/19/hello-world/","link":"","permalink":"http://blog.xueni.ren/2014/11/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.xueni.ren/categories/hexo/"}],"tags":[{"name":"hello","slug":"hello","permalink":"http://blog.xueni.ren/tags/hello/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"http://blog.xueni.ren/categories/hexo/"}]}]}