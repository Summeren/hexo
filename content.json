{"meta":{"title":"Apple","subtitle":null,"description":null,"author":"Apple","url":"http://blog.xueni.ren"},"pages":[{"title":"about","date":"2016-05-31T04:34:20.000Z","updated":"2016-06-07T15:41:34.130Z","comments":true,"path":"about/index.html","permalink":"http://blog.xueni.ren/about/index.html","excerpt":"","text":"Apple"},{"title":"tags","date":"2016-05-31T04:35:48.000Z","updated":"2016-06-07T15:41:34.130Z","comments":true,"path":"tags/index.html","permalink":"http://blog.xueni.ren/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringMVC 整合Mongodb","slug":"spring-data-mongodb","date":"2016-06-06T14:27:45.000Z","updated":"2016-06-07T15:41:34.130Z","comments":true,"path":"2016/06/06/spring-data-mongodb/","link":"","permalink":"http://blog.xueni.ren/2016/06/06/spring-data-mongodb/","excerpt":"引言平时都在用 SpringMVC 进行开发，但是，基本上都是在用 SpringMVC+Mybatis+MySQL 进行开发。对于 Mongodb 只是听说过，自己实际没有操作过，近期，在工作之余决定研究一下 Mongodb 。","text":"引言平时都在用 SpringMVC 进行开发，但是，基本上都是在用 SpringMVC+Mybatis+MySQL 进行开发。对于 Mongodb 只是听说过，自己实际没有操作过，近期，在工作之余决定研究一下 Mongodb 。那么，开始进入正题吧，此次我构建的项目是 SpringMVC+Mongodb+Maven ，有不对之处，还望指出。 作为一个 Maven 工程，我们还是先从 pom.xml 文件开始把,在 pom.xml 里配置我们的工程所依赖的 jar。pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.apple&lt;/groupId&gt; &lt;artifactId&gt;MongoDemo&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;MongoDemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 属性配置 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;jdk.version&gt;1.7&lt;/jdk.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring4支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-data-mongodb --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-mongodb&lt;/artifactId&gt; &lt;version&gt;1.7.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mongodb 驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- WEB --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!-- 编译需要而发布不需要的jar包 --&gt; &lt;/dependency&gt; &lt;!-- 阿里JSON包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j2核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 项目构建配置 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 资源 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 编译 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;$&#123;jdk.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;jdk.version&#125;&lt;/target&gt; &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;optimize&gt;true&lt;/optimize&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 发布 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;warName&gt;/&lt;/warName&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 接着就是web.xml 文件，有一点我们需要明确的就是， web.xml 文件并不是 web 工程所必须的，但是，一般情况下，我们都是以 web.xml 作为我们 web工程的入口。web.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:spring/applicationContext-dao.xml, classpath:spring/applicationContext-service.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.json&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsonp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.json&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsonp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.xueni.ren/categories/学习笔记/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://blog.xueni.ren/tags/SpringMVC/"},{"name":"整合Mongod","slug":"整合Mongod","permalink":"http://blog.xueni.ren/tags/整合Mongod/"}]},{"title":"Java 并发编程读书笔记(基础篇)","slug":"Java-compli-read-notes-basis","date":"2016-06-01T15:15:45.000Z","updated":"2016-06-07T15:41:34.130Z","comments":true,"path":"2016/06/01/Java-compli-read-notes-basis/","link":"","permalink":"http://blog.xueni.ren/2016/06/01/Java-compli-read-notes-basis/","excerpt":"基础篇，从各种概念开始。线程安全 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步货协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。","text":"基础篇，从各种概念开始。线程安全 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步货协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。 在线程安全类中封装来必要的同步机制，因此客户端无须进一步采取同步措施。 无状态对象一定是线程安全的。在并发编程中，这种由于不恰当的执行时序而出现的不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件。 原子操作作为一个不可分割的操作来执行。我们所熟知的 ++i 并不是一个原子操作，它实际上是一个 *¨读取 i 值 – 修改 i 值 – 写入 i 值¨ 的操作序列，并且其结果依赖于之前的状态。 内置锁每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为内置锁(Inteinsic Lock)或者监视器锁(Monitor Lock)。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。Java 的内置锁相当于一种互斥体(互斥锁)，这意味着最多只有一个线程能持有这种锁。 重入当某个线程请求一个由其他线程持有的锁是，发出请求的线程就会阻塞。¨重入¨ 意味着获取锁的操作的粒度是¨线程¨，而不是¨调用¨。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。 Volatile 关键字Java 语言提供来一种弱同步机制，即 volatile 变量，用来确保变量的更新操作通知到其他线程。仅当 volatile 变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用 volatile 变量。volatile 变量的正确使用方式包括：确保它们自身状态的可见性，确保它们锁引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生。 发布与逸出发布一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他对象，那么这些对象也都会被发布。当某个不应该发布的对象被发布时，就称为逸出。 线程封闭线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由该线程修改。 Ad-hoc 线程封闭Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。 栈封闭栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。栈封闭比 Ad-hoc 线程封闭更易于维护，也更健壮。 ThreadLocal 类维持线程封闭性的一种更规范方法是使用 ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 对象通常用于防止对可变的单实例变量或全局变量进行共享。 不变性如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。不可变对象一定是线程安全的。 当满足一下条件时，对象才是不可变的： 对象创建以后其状态就不能被修改。 对象的所有域都是 final 类型。 对象是正确创建的(在对象创建期间，this 引用没有逸出)。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.xueni.ren/categories/读书笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.xueni.ren/tags/Java/"}]},{"title":"MySQL 入库操作的优化","slug":"MySQL-batch-insert","date":"2016-06-01T14:22:22.000Z","updated":"2016-06-07T15:41:34.130Z","comments":true,"path":"2016/06/01/MySQL-batch-insert/","link":"","permalink":"http://blog.xueni.ren/2016/06/01/MySQL-batch-insert/","excerpt":"最近开始玩 MyBatis ，想实现这么一个功能，就是将一张表里的数据作为历史数据存储到另一张表里去。一开始我的代码是这么写的：","text":"最近开始玩 MyBatis ，想实现这么一个功能，就是将一张表里的数据作为历史数据存储到另一张表里去。一开始我的代码是这么写的： 1234567List&lt;BookHistory&gt; bookHistories = bookHisDao.getBookList();//获取需要存储的历史数据for (BookHistory BookHistory:bookHistories) &#123; BookHistory book = bookHisDao.selectBookById(BookHistory); if(null == book)&#123; bookHisDao.insertBook(bookHistory);// 数据入库操作 &#125;&#125; 看起来简单粗暴，似乎没有什么问题，查询出来一个list，然后循环遍历，检查是否已经存在历史库中，如果不存在则入库。功能也正确实现，但是，存在的问题是，速度有点太慢。2007 条数据的执行时间是 2m 1s 505ms 。对于追求完美的我，这是不能忍受的，首先我能想到的就是优化入库操作，因为一条数据一条数据的插入，确实会速度特别慢，说干就干，首先先将入库操作由原来的一条一条入库改成批量入库。接下来我的代码变成了这样： 1234567891011List&lt;BookHistory&gt; bookHistories = bookHisDao.getBookList();Iterator&lt;BookHistory&gt; bookIter= bookHistories.iterator();while (bookIter.hasNext())&#123; BookHistory bookHistory = bookIter.next(); BookHistory book = bookHisDao.selectBookById(bookHistory); if(null != book)&#123; bookIter.remove(); &#125;&#125;int count = bookHisDao.insertBookBatch(bookHistories);//批量入库操作System.out.println(\"insert \"+count+\" records\"); 改成批量入库操作后，速度直线上升，2007条数据的执行时间是 6s 737ms ，现在看来，情况很乐观，但是随之而来的又出来了另一个问题，因为做测试，我并没有将所有字段都进行入库操作。 当我把字段补齐时，控制台报了这样一个错： 123org.springframework.dao.TransientDataAccessResourceException: ### Error updating database. Cause: com.mysql.jdbc.PacketTooBigException: Packet for query is too large (13513737 &gt; 4194304). You can change this value on the server by setting the max_allowed_packet&apos; variable.### The error may involve BookHistory.insertBookBatch-Inline 看到控制台提到了 max_allowed_packet 这个参数，那么我们就需要了解一下，这个参数是干什么用的。max_allowed_packet 是 MySQL 变量的一个变量，用于控制其通信缓冲区的最大长度。默认值是：4194304.从控制台的报错信息可以看出来，我此时需要的缓冲区长度为：13513737，远大于4194304。最简单粗暴的办法就是修改 MySQL 的 max_allowed_packet 参数。修改这个参数，可以暂时的解决问题，但是不能长久的解决问题，因为我无法保证线上的数据量会是多大。这时候，我需要寻找别的突破点。既然2007条数据同时入库，会导致 MySQL 的缓冲区不够用，那么，我是否可以改一下自己的程序，不让数据一次性都插入，而是，分批插入，比如说每次 500 条数据呢？接下来，我又对我的代码做了如下修改： 123456789101112131415161718192021222324252627List&lt;BookHistory&gt; bookHistories = bookHisDao.getBookList();Iterator&lt;BookHistory&gt; bookIter= bookHistories.iterator();while (bookIter.hasNext())&#123; BookHistory bookHistory = bookIter.next(); BookHistory book = bookHisDao.selectBookById(bookHistory); if(null != book)&#123; bookIter.remove(); &#125;&#125;//int count = bookHisDao.insertBookBatch(bookHistories);//批量入库操作//System.out.println(\"insert \"+count+\" records\");//分批，批量入库操作int batch = 0;List&lt;BookHistory&gt; bookList = new ArrayList&lt;BookHistory&gt;();for (BookHistory bookHistory:bookHistories)&#123; batch++; bookList.add(bookHistory); System.out.println(batch); if (batch == 500)&#123; bookHisDao.insertBookBatch(bookList); System.out.println(bookList.size()); batch = 0; bookList.clear(); &#125;&#125;bookHisDao.insertBookBatch(bookList); 这样一修改之后，控制台的错误消失，程序的运行速度是 8s 393ms 。比刚才的 一次性批量入库慢了 2s 。。。暂时还没有想到更好的解决方案，先这样，我再想想还有么有更好的解决方案。以上的修改，虽然解决了问题，但是代码不够优雅。 最后，我们需要思考的问题是，为什么 MySQL 入库，批量入库比一条一条的数据入库性能好很多？","categories":[{"name":"Java 编程","slug":"Java-编程","permalink":"http://blog.xueni.ren/categories/Java-编程/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.xueni.ren/tags/MySQL/"}]},{"title":"test","slug":"test","date":"2015-11-18T16:00:00.000Z","updated":"2016-06-07T15:41:34.130Z","comments":true,"path":"2015/11/19/test/","link":"","permalink":"http://blog.xueni.ren/2015/11/19/test/","excerpt":"md语法","text":"md语法 This is an h1 tagThis is an h2 tagThis is an h6 tagThis text will be italicThis will also be italic This text will be boldThis will also be bold You can combine them Item 1 Item 2 Item 2a Item 2b Item 1 Item 2 Item 3 Item 3a Item 3b As Kanye West said: We’re living the future sothe present is our past. I think you should use an&lt;addr&gt; element here instead. 12345function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; [x] @mentions, #refs, links, formatting, and tags supported [x] list syntax required (any unordered or ordered list supported) [x] this is a complete item [ ] this is an incomplete item First Header Second Header Content from cell 1 Content from cell 2 Content in the first column Content in the second column @octocat :+1: This PR looks great - it’s ready to merge! :shipit:","categories":[{"name":"categories","slug":"categories","permalink":"http://blog.xueni.ren/categories/categories/"}],"tags":[{"name":"test","slug":"test","permalink":"http://blog.xueni.ren/tags/test/"}]},{"title":"发布pelican博客","slug":"pelican-blog","date":"2015-03-31T16:00:00.000Z","updated":"2016-06-07T15:41:34.130Z","comments":true,"path":"2015/04/01/pelican-blog/","link":"","permalink":"http://blog.xueni.ren/2015/04/01/pelican-blog/","excerpt":"","text":"没有前言，没有概述，做个笔记而已。 在content目录里新建 .py 文件，写完之后执行pelican content，生成页面。 cd 到output里 执行python -m pelican.server。 localhost:8000 查看效果。 cd到blog的根目录，执行 sh push_to.sh。 最后，记得也要把blog的content也push到github上。","categories":[{"name":"pelican","slug":"pelican","permalink":"http://blog.xueni.ren/categories/pelican/"},{"name":"python","slug":"pelican/python","permalink":"http://blog.xueni.ren/categories/pelican/python/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://blog.xueni.ren/tags/blog/"}]},{"title":"Hello World","slug":"hello-world","date":"2014-11-18T16:00:00.000Z","updated":"2016-06-07T15:41:34.130Z","comments":true,"path":"2014/11/19/hello-world/","link":"","permalink":"http://blog.xueni.ren/2014/11/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.xueni.ren/categories/hexo/"}],"tags":[{"name":"hello","slug":"hello","permalink":"http://blog.xueni.ren/tags/hello/"}]}]}